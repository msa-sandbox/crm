# CRM API Architecture Documentation

## Table of Contents

1. [Overview](#overview)
2. [Architecture Approach](#architecture-approach)
3. [Project Structure](#project-structure)
4. [API Versioning Strategy](#api-versioning-strategy)
5. [Domain-Driven Design](#domain-driven-design)
6. [Authentication & Authorization](#authentication--authorization)
7. [Rate Limiting](#rate-limiting)
8. [Data Flow Examples](#data-flow-examples)
9. [Key Principles](#key-principles)
10. [Technology Stack](#technology-stack)

---

## Overview

The **CRM API Service** is a standalone microservice built with **Symfony 7.3**, following **Domain-Driven Design (DDD)** and **Clean Architecture** principles. It manages **Contacts** and **Leads** domains and integrates with an external **Auth Service** for JWT-based authentication. Token invalidation events are handled via **Kafka** and **Redis**.

**Key Features:**

* Domain-Driven Design with bounded contexts
* API versioning (v1) with isolated presentation layer
* JWT validation with external Auth Service
* Token invalidation via Kafka
* Rate limiting per user
* Redis caching and Prometheus metrics
* Transactional consistency and strict permission control

---

## Architecture Approach

The service combines **DDD** and **Clean Architecture**, ensuring strict separation of concerns and inward dependency flow.

### Architecture Layers

```
┌─────────────────────────────────────────────┐
│ Presentation Layer (API v1)                 │  <- Controllers, DTOs, Transformers
├─────────────────────────────────────────────┤
│ Application Layer (Use Cases / Handlers)    │  <- Command & Query handlers
├─────────────────────────────────────────────┤
│ Domain Layer (Business Logic)               │  <- Entities, Value Objects, Services
├─────────────────────────────────────────────┤
│ Infrastructure Layer                        │  <- Doctrine, Kafka, Redis, Security
└─────────────────────────────────────────────┘
```

**Principle:** Business logic is completely independent of frameworks or delivery mechanisms.

---

## Project Structure

```
src/
├── Api/
│   ├── Controller/
│   │   ├── GeneralController.php
│   │   └── HealthController.php
│   └── V1/
│       ├── Controller/            # Versioned API endpoints
│       │   ├── ContactController.php
│       │   └── LeadController.php
│       ├── Dto/                   # Request DTOs
│       │   ├── DtoCollectionInterface.php
│       │   └── Request/
│       │       ├── Contact/       # Contact specific DTOs
│       │       └── Lead/          # Lead specific DTOs
│       ├── EventListener/
│       │   ├── ExceptionListener.php
│       │   ├── Middleware/        # All custom middleware
│       │   └── ResponseListener.php
│       ├── Factory/               # Entity factories from request DTOs 
│       │   ├── ContactFactory.php
│       │   └── LeadFactory.php
│       ├── Handler/               # Application use case coordinators
│       │   ├── Contact/
│       │   │   ├── CreateContactHandler.php
│       │   │   └── GetContactHandler.php
│       │   └── Lead/
│       │       ├── CreateLeadHandler.php
│       │       └── GetLeadHandler.php
│       ├── Response/
│       │   └── ApiResponse.php
│       └── Transformer/           # Response DTO transformers
│
├── CRM/                           # Domain layer: entities, services, contracts, etc.
│   ├── Contact/
│   │   ├── Contract/, Entity/, Enum/, Repository/, Service/, ValueObject/
│   └── Lead/
│       ├── Contract/, Entity/, Enum/, Repository/, Service/, ValueObject/
│
├── Command/Api/                   # CLI integration tests and utility commands
├── Exception/                     # Domain and infrastructure exceptions
├── Infrastructure/                # Kafka, Redis, RateLimiter implementations
├── Security/                      # JWT, permissions, user model
├── Serializer/                    # Custom DTO normalizers
├── Service/                       # Shared app-level services (TransactionManager)
├── DataFixtures/                  # Sample data for local/testing environments
└── Kernel.php
```

---

## API Versioning Strategy

### Why Version the Entire API?

Each API version (v1, v2, etc.) is isolated. This ensures stable contracts and enables breaking changes without affecting existing clients.

Each version defines its own controllers, DTOs, transformers, and validation logic — the domain layer remains shared and stable.

---

## Domain-Driven Design

The domain is organized into **bounded contexts** — `Lead` and `Contact`. Each has:

* Entities & Value Objects
* Services (Command & Query)
* Repositories & Contracts

Communication between domains happens via service coordination or shared IDs, never direct entity coupling.

---

## Authentication & Authorization

The CRM API validates **JWT tokens** generated by an external **Auth Service**.
The current project **never** sends requests to Auth Service directly but instead uses its public key to verify signatures.

### Invalidation via Kafka

1. Auth Service emits `user.token.invalidated` event.
2. CRM consumes event via Kafka.
3. Timestamp stored in Redis under `invalidated_user_{id}`.
4. Old tokens are rejected on next request.

---

## Rate Limiting

Implemented via **custom middleware** `RateLimitPerUserListener`, extending Symfony’s RateLimiter logic.

* Per-user limits.
* Headers automatically included:
* Returns `429 Too Many Requests` when exceeded.

---

## Data Flow Examples

### Example 1: GET /api/v1/leads

```
Request
 → LeadController
   → GetLeadHandler
     → PermissionChecker
     → GetLeadService
     → LeadRepository
     → LeadTransformer
 ← JSON Response (200 OK)
```

### Example 2: POST /api/v1/leads/complex

```
Request
 → LeadController
   → CreateLeadHandler::createBulkWithContacts
     → CreateContactService (if new contacts)
     → CreateLeadService
     → TransactionManager (atomic execution)
     → LeadCoreTransformer
 ← JSON Response (201 Created)
```

---

## Key Principles

1. **Separation of Concerns** — Domain is independent from infrastructure.
2. **Dependency Inversion** — Dependencies always point inward.
3. **API Version Isolation** — Each API version has its own contracts.
4. **Transactional Integrity** — TransactionManager ensures atomic operations.
5. **Security First** — JWT validation, permission checks, rate limiting.
6. **Event-Driven Extensions** — Kafka for async updates and invalidations.

---

## Technology Stack

| Component          | Technology                        | Purpose                              |
| ------------------ | --------------------------------- | ------------------------------------ |
| **Framework**      | Symfony 7.3                       | Core framework                       |
| **Language**       | PHP 8.3+                          | Application logic                    |
| **ORM**            | Doctrine ORM 3.x                  | Data persistence                     |
| **Database**       | MySQL 8.x                         | Relational storage                   |
| **Authentication** | LexikJWTAuthenticationBundle      | JWT validation                       |
| **Messaging**      | Kafka (rdkafka extension)         | Event streaming & token invalidation |
| **Cache**          | Redis                             | Token invalidation, rate limiting    |
| **Validation**     | Symfony Validator                 | DTO validation                       |
| **Metrics**        | Prometheus Metrics Bundle         | Monitoring                           |
| **Testing**        | PHPUnit 11, PHPStan, PHP CS Fixer | Code quality                         |
