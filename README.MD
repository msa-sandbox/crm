# CRM Service

## Overview

The **CRM Service** is a microservice responsible for managing **leads** and **contacts** within a distributed MSA environment. It is built with **Symfony 7.3** and follows **Domain-Driven Design (DDD)** principles combined with **Clean Architecture** patterns.

The service exposes a REST API for CRUD operations on Leads and Contacts, using JWT authentication delegated to an external **Auth Service**. Kafka is used for token invalidation and inter-service communication.

---

## Architecture

The project applies a **pragmatic DDD** approach with clear separation between layers:

```
Presentation (API) → Application (Handlers) → Domain (Entities, Services) → Infrastructure (Doctrine, Redis, Kafka)
```

* **Presentation Layer** — DTOs, Controllers, Transformers, and Handlers for each API version.
* **Application Layer** — Use case coordinators (Handlers) responsible for orchestrating domain logic and permissions.
* **Domain Layer** — Core business logic, entities, value objects, repositories, and specifications.
* **Infrastructure Layer** — Database, cache, and external integrations (MySQL, Redis, Kafka, Auth Service).

**Key principles:**

* Domain is independent from frameworks.
* Dependency flow is strictly inward.
* Each bounded context (Lead, Contact) is isolated.

**Related diagrams:**

* [Architecture Layers](docs/1-architecture-layers.puml)
* [Domain Structure](docs/3-domain-structure2.puml)
* [API Request Flow](docs/4-api-request-flow.puml)

---

## Technology Stack

- **Symfony 7.3** – framework (routing, DI, validation)
- **Doctrine ORM 3.x** – database persistence
- **MySQL 8.x** – relational database
- **LexikJWTAuthenticationBundle** – JWT token creation/validation
- **RdKafka** – Kafka producer/consumer
- **Prometheus Metrics Bundle** – custom metrics collection
- **PHPStan (level 5) / PHP CS Fixer / PHPUnit** – code quality tools


---

## Core Domains

### Lead

Represents a potential client or opportunity. Contains business fields such as title, status, pipeline stage, and relations to contacts.

### Contact

Represents a person or organization associated with leads. Supports deduplication and merging logic by email.

> Only these two domains are currently implemented.

---

## Authentication & Authorization

* The service does **not** issue tokens; it validates JWTs generated by an external **Auth Service**.
* Tokens are checked through:

  - **Signature validation** using a public key.
  - **Expiration check.**
  - **Redis invalidation check** (invalidation events from Kafka).

**Diagram:** [Authentication Flow](docs/2-authentication-flow.puml)

Access control is handled by a centralized `PermissionChecker`, which verifies permissions for entities like Lead and Contact per action (READ, WRITE).

---

## API Request Flow

### POST /api/v1/leads (create lead)

```
HTTP Request (JSON body)
    ↓
LeadController::create()
    ↓
CreateLeadHandler::createBulk(CreateLeadCollectionDto)
    ├→ PermissionChecker::assertGranted(User, LEAD:WRITE)
    ├→ LeadFactory::fromDto(CreateLeadDto)
    ├→ CreateLeadService::createLeads(array $leads)
    │   ├→ Validate business rules
    │   ├→ LeadRepository::add($lead)
    │   └→ TransactionManager::commit()
    ├→ LeadCoreTransformer::transformCollection($leads)
    └→ return ApiResponse(success: true, data: ...)
    ↓
Controller → JSON Response (200 OK)
```

### GET /api/v1/leads?with=contacts

```
HTTP Request (query params)
    ↓
LeadController::getList(GetLeadQueryDto)
    ↓
GetLeadHandler::getList(GetLeadQueryDto)
    ├→ PermissionChecker::assertGranted(User, LEAD:READ)
    ├→ LeadSearchCriteria::fromQueryDto($queryDto)
    ├→ GetLeadService::getLeadsByAccount(LeadSearchCriteria)
    │   └→ LeadRepository::findByAccountId($criteria)
    ├→ if 'contacts' in with → PermissionChecker::assertGranted(User, CONTACT:READ)
    ├→ LeadTransformer::transformCollection($leads, $queryDto->getWith())
    └→ return ApiResponse(success: true, data: ...)
    ↓
Controller → JSON Response (200 OK)
```

---

## Running Locally

### Prerequisites

* Docker and Docker Compose installed
* Make sure port **8082** is available

### Start services

```bash
    docker-compose up -d
```

### Run migrations

```bash
    docker exec -it crm-php php bin/console doctrine:migrations:migrate
```

### Access the API

```
https://localhost:8082/api/v1/leads
```

Environment variables are defined in `.env` and include default values for:

* Database (MySQL)
* Redis
* Kafka
* JWT public/private keys

---

## Monitoring

* **Metrics endpoint:** `/metrics` (Prometheus format)
* **Health check:** `/health`

---

## Testing

The project includes a **comprehensive automated test suite** that verifies correctness across all major layers.

### Test Types

| Type                  | Scope                                         | Description                                                                                                                 |
|-----------------------|-----------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------|
| **Unit Tests**        | Domain services, factories, and value objects | Validate isolated business logic and internal consistency.                                                                  |
| **Integration Tests** | Handlers, repositories, transactions          | Execute against a real **MySQL test database** (no mocks). Cover data persistence, permission checks, and entity relations. |

I do not have functional tests since they will repeat the same scenarios as integration tests.

All tests run in the **`test` environment**, with a clean schema automatically created before execution via Doctrine’s `SchemaTool`. A fake authenticated user is injected for permission validation.

### Key Highlights

* Real DB interactions, no mocks
* Automatic DB cleanup for isolation
* Transactional rollback and consistency checks
* Coverage for pagination, search, and relation logic
* PHPUnit 11.x + strict assertions

### Running Tests

You can run the full test suite via Composer:

```bash
  composer unit
```

> The integration tests closely simulate real API usage — each scenario mirrors actual system behavior (create, query, relate entities) to ensure end-to-end data flow validation.


---

## Documentation

All extended documentation and diagrams are available in the [`/docs`](docs/) directory

